"""
Sistema Adaptativo de Estrat√©gias para Trading
Analisa condi√ß√µes de mercado em tempo real e seleciona automaticamente
a melhor estrat√©gia (Martingale Premium Conservative vs Infinity Conservative)
"""

import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import pandas as pd

from .parser import Signal
from .config import Config

logger = logging.getLogger(__name__)


class StrategyType(Enum):
    """Tipos de estrat√©gia dispon√≠veis."""
    MARTINGALE_CONSERVATIVE = "martingale_conservative"
    INFINITY_CONSERVATIVE = "infinity_conservative"
    PAUSE = "pause"


@dataclass
class StrategyMetrics:
    """M√©tricas de uma estrat√©gia."""
    win_rate: float
    roi_monthly: float
    risk_per_session: float
    max_attempts: int
    profit_per_win: float
    
    def __str__(self) -> str:
        return (f"Win Rate: {self.win_rate:.1f}% | "
                f"ROI: {self.roi_monthly:.1f}% | "
                f"Risk: ${self.risk_per_session}")


@dataclass
class MarketConditions:
    """Condi√ß√µes atuais do mercado baseadas na an√°lise de sinais."""
    total_operations: int
    first_attempt_success_rate: float
    g1_recovery_rate: float
    g2_plus_stop_rate: float
    recommended_strategy: StrategyType
    confidence_level: float
    analysis_period: str
    
    def __str__(self) -> str:
        return (f"üîç An√°lise {self.analysis_period}: {self.total_operations} ops | "
                f"1¬™: {self.first_attempt_success_rate:.1f}% | "
                f"G1: {self.g1_recovery_rate:.1f}% | "
                f"G2+STOP: {self.g2_plus_stop_rate:.1f}% | "
                f"Estrat√©gia: {self.recommended_strategy.value.upper()} "
                f"(Confian√ßa: {self.confidence_level:.1f}%)")


class AdaptiveStrategy:
    """Sistema adaptativo de sele√ß√£o de estrat√©gias."""
    
    def __init__(self, config: Config):
        self.config = config
        self.timezone = config.timezone
        
        # Configura√ß√µes das estrat√©gias
        self.strategies = {
            StrategyType.MARTINGALE_CONSERVATIVE: StrategyMetrics(
                win_rate=78.7,
                roi_monthly=56.0,
                risk_per_session=36.0,
                max_attempts=2,
                profit_per_win=4.0
            ),
            StrategyType.INFINITY_CONSERVATIVE: StrategyMetrics(
                win_rate=92.3,
                roi_monthly=45.1,
                risk_per_session=49.0,
                max_attempts=7,
                profit_per_win=6.0
            )
        }
        
        # Crit√©rios de decis√£o
        self.decision_thresholds = {
            'pause_threshold': 30.0,  # Se G2+STOP > 30%, pausar
            'martingale_threshold': 65.0,  # Se G1 recovery > 65%, usar Martingale
            'infinity_threshold': 60.0,  # Se 1¬™ tentativa > 60%, usar Infinity
            'min_operations': 10,  # M√≠nimo de opera√ß√µes para an√°lise confi√°vel
            'confidence_threshold': 70.0  # Confian√ßa m√≠nima para mudan√ßa
        }
        
        # Estado atual
        self.current_strategy: Optional[StrategyType] = None
        self.last_analysis_time: Optional[datetime] = None
        self.analysis_history: List[MarketConditions] = []
        
    def analyze_market_conditions(self, signals: List[Signal]) -> MarketConditions:
        """
        Analisa condi√ß√µes do mercado baseado nos sinais coletados.
        
        Args:
            signals: Lista de sinais para an√°lise
            
        Returns:
            Condi√ß√µes do mercado e estrat√©gia recomendada
        """
        if not signals:
            return MarketConditions(
                total_operations=0,
                first_attempt_success_rate=0.0,
                g1_recovery_rate=0.0,
                g2_plus_stop_rate=0.0,
                recommended_strategy=StrategyType.PAUSE,
                confidence_level=0.0,
                analysis_period="Sem dados"
            )
        
        # Agrupar sinais por opera√ß√£o (mesmo asset + tempo pr√≥ximo)
        operations = self._group_signals_into_operations(signals)
        
        # Calcular m√©tricas
        total_ops = len(operations)
        first_attempt_wins = sum(1 for op in operations if op['result'] == 'W' and op['attempts'] == 1)
        g1_recoveries = sum(1 for op in operations if op['result'] == 'W' and op['attempts'] == 2)
        g2_plus_stops = sum(1 for op in operations if op['attempts'] >= 3)
        
        # Calcular taxas
        first_attempt_rate = (first_attempt_wins / total_ops * 100) if total_ops > 0 else 0
        g1_recovery_rate = (g1_recoveries / max(1, total_ops - first_attempt_wins) * 100) if total_ops > first_attempt_wins else 0
        g2_plus_stop_rate = (g2_plus_stops / total_ops * 100) if total_ops > 0 else 0
        
        # Determinar estrat√©gia recomendada
        recommended_strategy, confidence = self._determine_strategy(
            total_ops, first_attempt_rate, g1_recovery_rate, g2_plus_stop_rate
        )
        
        # Per√≠odo de an√°lise
        if signals:
            start_time = min(signal.timestamp for signal in signals)
            end_time = max(signal.timestamp for signal in signals)
            period = f"{start_time.strftime('%H:%M')}-{end_time.strftime('%H:%M')}"
        else:
            period = "N/A"
        
        return MarketConditions(
            total_operations=total_ops,
            first_attempt_success_rate=first_attempt_rate,
            g1_recovery_rate=g1_recovery_rate,
            g2_plus_stop_rate=g2_plus_stop_rate,
            recommended_strategy=recommended_strategy,
            confidence_level=confidence,
            analysis_period=period
        )
    
    def _group_signals_into_operations(self, signals: List[Signal]) -> List[Dict[str, Any]]:
        """
        Agrupa sinais em opera√ß√µes completas.
        
        Args:
            signals: Lista de sinais
            
        Returns:
            Lista de opera√ß√µes com resultado final
        """
        operations = []
        signals_by_asset = {}
        
        # Agrupar por ativo
        for signal in sorted(signals, key=lambda x: x.timestamp):
            if signal.asset not in signals_by_asset:
                signals_by_asset[signal.asset] = []
            signals_by_asset[signal.asset].append(signal)
        
        # Processar cada ativo
        for asset, asset_signals in signals_by_asset.items():
            i = 0
            while i < len(asset_signals):
                current_signal = asset_signals[i]
                
                # Se √© um WIN, determinar em qual tentativa
                if current_signal.result == 'W':
                    attempts = current_signal.attempt if current_signal.attempt else 1
                    operations.append({
                        'asset': asset,
                        'timestamp': current_signal.timestamp,
                        'result': 'W',
                        'attempts': attempts
                    })
                    i += 1
                
                # Se √© um LOSS, contar quantas tentativas foram feitas
                elif current_signal.result == 'L':
                    # Procurar tentativas anteriores pr√≥ximas
                    attempts = 1
                    j = i - 1
                    
                    # Verificar sinais anteriores no mesmo ativo
                    while j >= 0 and (current_signal.timestamp - asset_signals[j].timestamp).total_seconds() <= 600:  # 10 minutos
                        if asset_signals[j].asset == asset:
                            attempts += 1
                        j -= 1
                    
                    # M√°ximo de 3 tentativas
                    attempts = min(attempts, 3)
                    
                    operations.append({
                        'asset': asset,
                        'timestamp': current_signal.timestamp,
                        'result': 'L',
                        'attempts': attempts
                    })
                    i += 1
                else:
                    i += 1
        
        return operations
    
    def _determine_strategy(self, total_ops: int, first_rate: float, g1_rate: float, g2_stop_rate: float) -> Tuple[StrategyType, float]:
        """
        Determina a melhor estrat√©gia baseada nas m√©tricas.
        
        Args:
            total_ops: Total de opera√ß√µes
            first_rate: Taxa de sucesso na 1¬™ tentativa
            g1_rate: Taxa de recupera√ß√£o no G1
            g2_stop_rate: Taxa de G2+STOP
            
        Returns:
            Tupla com (estrat√©gia recomendada, confian√ßa)
        """
        # Verificar se h√° dados suficientes
        if total_ops < self.decision_thresholds['min_operations']:
            return StrategyType.PAUSE, 30.0
        
        # Crit√©rio 1: Se G2+STOP muito alto, pausar
        if g2_stop_rate > self.decision_thresholds['pause_threshold']:
            confidence = min(95.0, g2_stop_rate * 2)
            return StrategyType.PAUSE, confidence
        
        # Crit√©rio 2: Se alta taxa de recupera√ß√£o G1, usar Martingale
        if g1_rate > self.decision_thresholds['martingale_threshold']:
            confidence = min(90.0, g1_rate + 20)
            return StrategyType.MARTINGALE_CONSERVATIVE, confidence
        
        # Crit√©rio 3: Se alta taxa de 1¬™ tentativa, usar Infinity
        if first_rate > self.decision_thresholds['infinity_threshold']:
            confidence = min(85.0, first_rate + 15)
            return StrategyType.INFINITY_CONSERVATIVE, confidence
        
        # Caso intermedi√°rio: comparar ROI potencial
        martingale_score = self._calculate_strategy_score(
            StrategyType.MARTINGALE_CONSERVATIVE, first_rate, g1_rate, g2_stop_rate
        )
        infinity_score = self._calculate_strategy_score(
            StrategyType.INFINITY_CONSERVATIVE, first_rate, g1_rate, g2_stop_rate
        )
        
        if martingale_score > infinity_score:
            confidence = min(75.0, abs(martingale_score - infinity_score) * 10 + 50)
            return StrategyType.MARTINGALE_CONSERVATIVE, confidence
        else:
            confidence = min(75.0, abs(infinity_score - martingale_score) * 10 + 50)
            return StrategyType.INFINITY_CONSERVATIVE, confidence
    
    def _calculate_strategy_score(self, strategy: StrategyType, first_rate: float, g1_rate: float, g2_stop_rate: float) -> float:
        """
        Calcula score de uma estrat√©gia baseada nas condi√ß√µes atuais.
        
        Args:
            strategy: Tipo de estrat√©gia
            first_rate: Taxa de 1¬™ tentativa
            g1_rate: Taxa de G1
            g2_stop_rate: Taxa de G2+STOP
            
        Returns:
            Score da estrat√©gia (maior = melhor)
        """
        metrics = self.strategies[strategy]
        
        if strategy == StrategyType.MARTINGALE_CONSERVATIVE:
            # Martingale se beneficia de alta recupera√ß√£o G1
            win_rate_adjusted = first_rate + (g1_rate * 0.7)  # G1 vale 70% de um win
            risk_penalty = g2_stop_rate * 0.5  # Penalizar G2+STOP
            
        elif strategy == StrategyType.INFINITY_CONSERVATIVE:
            # Infinity se beneficia de alta taxa de 1¬™ tentativa
            win_rate_adjusted = first_rate * 1.2  # Bonus para 1¬™ tentativa
            risk_penalty = g2_stop_rate * 0.3  # Menos penalidade pois usa menos capital
        
        else:
            return 0.0
        
        # Score final considera ROI potencial e ajustes de risco
        base_score = metrics.roi_monthly
        adjusted_score = base_score * (win_rate_adjusted / 100) - risk_penalty
        
        return max(0.0, adjusted_score)
    
    def should_change_strategy(self, new_conditions: MarketConditions) -> bool:
        """
        Determina se deve mudar a estrat√©gia atual.
        
        Args:
            new_conditions: Novas condi√ß√µes do mercado
            
        Returns:
            True se deve mudar estrat√©gia
        """
        # Se n√£o h√° estrat√©gia atual, sempre mudar
        if self.current_strategy is None:
            return True
        
        # Se a nova estrat√©gia √© diferente da atual
        if new_conditions.recommended_strategy != self.current_strategy:
            # S√≥ mudar se a confian√ßa for alta o suficiente
            return new_conditions.confidence_level >= self.decision_thresholds['confidence_threshold']
        
        return False
    
    def update_strategy(self, conditions: MarketConditions) -> bool:
        """
        Atualiza a estrat√©gia atual baseada nas condi√ß√µes.
        
        Args:
            conditions: Condi√ß√µes atuais do mercado
            
        Returns:
            True se houve mudan√ßa de estrat√©gia
        """
        changed = self.should_change_strategy(conditions)
        
        if changed:
            old_strategy = self.current_strategy
            self.current_strategy = conditions.recommended_strategy
            self.last_analysis_time = datetime.now(self.timezone)
            
            logger.info(f"üîÑ Mudan√ßa de estrat√©gia: {old_strategy} -> {self.current_strategy}")
            logger.info(f"üìä {conditions}")
            
            # Salvar no hist√≥rico
            self.analysis_history.append(conditions)
            
            return True
        
        return False
    
    def get_current_strategy_info(self) -> Dict[str, Any]:
        """
        Retorna informa√ß√µes da estrat√©gia atual.
        
        Returns:
            Informa√ß√µes da estrat√©gia
        """
        if self.current_strategy is None:
            return {
                'strategy': None,
                'status': 'Aguardando an√°lise inicial',
                'metrics': None
            }
        
        if self.current_strategy == StrategyType.PAUSE:
            return {
                'strategy': self.current_strategy,
                'status': 'Trading pausado - condi√ß√µes desfavor√°veis',
                'metrics': None
            }
        
        metrics = self.strategies[self.current_strategy]
        
        return {
            'strategy': self.current_strategy,
            'status': f'Ativo - {self.current_strategy.value.replace("_", " ").title()}',
            'metrics': metrics,
            'last_analysis': self.last_analysis_time
        }
    
    def get_analysis_summary(self) -> str:
        """
        Retorna resumo das an√°lises recentes.
        
        Returns:
            Resumo formatado
        """
        if not self.analysis_history:
            return "üìä Nenhuma an√°lise realizada ainda"
        
        recent = self.analysis_history[-5:]  # √öltimas 5 an√°lises
        
        summary = ["üìä Resumo das An√°lises Recentes:", ""]
        
        for i, analysis in enumerate(recent, 1):
            summary.append(f"{i}. {analysis}")
        
        summary.append("")
        summary.append(f"üéØ Estrat√©gia Atual: {self.current_strategy.value.upper() if self.current_strategy else 'Indefinida'}")
        
        return "\n".join(summary) 