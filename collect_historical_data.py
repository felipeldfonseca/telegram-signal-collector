#!/usr/bin/env python3
"""
Coleta TODOS os sinais de hoje (sem filtro de hor√°rio) e faz an√°lise completa
Prepara o sistema para trading adaptativo das 17:00-23:59
"""

import asyncio
import sys
import os
from datetime import datetime, timedelta
import pytz

# Adicionar diret√≥rio do projeto ao path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from collector import Config, AdaptiveStrategy, Storage
from collector.runner import Runner
from collector.parser import Signal
from collector.regex import find_signal


class FullDayParser:
    """Parser que coleta sinais de qualquer hor√°rio."""
    
    def __init__(self, config: Config):
        self.config = config
        self.timezone = config.timezone
    
    def parse_message_no_time_filter(self, message) -> Signal:
        """
        Parse mensagem SEM filtro de hor√°rio.
        
        Args:
            message: Mensagem do Telegram
            
        Returns:
            Signal ou None
        """
        try:
            if not message.text:
                return None
            
            # Extrair sinal usando regex
            signal_data = find_signal(message.text)
            if not signal_data:
                return None
            
            result, attempt, asset = signal_data
            
            # Converter timestamp
            timestamp = message.date
            if timestamp.tzinfo is None:
                timestamp = pytz.UTC.localize(timestamp)
            
            local_timestamp = timestamp.astimezone(self.timezone)
            
            # Criar signal SEM valida√ß√£o de hor√°rio
            signal = Signal(
                timestamp=local_timestamp,
                asset=asset,
                result=result,
                attempt=attempt
            )
            
            return signal
            
        except Exception as e:
            print(f"Erro ao processar mensagem: {e}")
            return None


async def collect_full_day_data():
    """Coleta TODOS os sinais de hoje."""
    print("üìä COLETANDO TODOS OS SINAIS DE HOJE")
    print("=" * 60)
    
    config = Config()
    config.setup_logging()
    runner = Runner(config)
    storage = Storage(config)
    parser = FullDayParser(config)
    
    try:
        # Conectar ao Telegram
        print("üì° Conectando ao Telegram...")
        await runner.setup_client()
        
        # Definir per√≠odo (06:00 at√© agora)
        now = datetime.now(config.timezone)
        today_start = now.replace(hour=6, minute=0, second=0, microsecond=0)
        
        print(f"üïê Per√≠odo: {today_start.strftime('%H:%M')} at√© {now.strftime('%H:%M')}")
        print(f"üìÖ Data: {now.strftime('%d/%m/%Y')}")
        
        # Coletar mensagens manualmente
        print("\nüîç Coletando mensagens...")
        entity = await runner.get_chat_entity()
        
        signals = []
        message_count = 0
        
        async for message in runner.client.iter_messages(entity, limit=500):
            # Verificar se est√° no per√≠odo
            local_time = message.date.astimezone(config.timezone)
            
            if local_time < today_start:
                break  # Mensagens muito antigas
            
            if local_time > now:
                continue  # Mensagens futuras (n√£o deveria acontecer)
            
            message_count += 1
            
            # Tentar extrair sinal
            signal = parser.parse_message_no_time_filter(message)
            if signal:
                signals.append(signal)
        
        print(f"‚úÖ Processadas {message_count} mensagens")
        print(f"üéØ Encontrados {len(signals)} sinais")
        
        if signals:
            # Salvar dados
            print("\nüíæ Salvando dados...")
            storage.save_to_csv(signals, now)
            
            # Estat√≠sticas detalhadas
            print("\nüìà ESTAT√çSTICAS COMPLETAS DO DIA:")
            print("-" * 50)
            
            # Agrupar por resultado (conforme estrat√©gias: apenas 1¬™ tentativa + G1 s√£o wins)
            first_attempt_wins = [s for s in signals if s.result == 'W' and s.attempt == 1]
            g1_wins = [s for s in signals if s.result == 'W' and s.attempt == 2]
            wins = first_attempt_wins + g1_wins  # Apenas 1¬™ tentativa + G1
            losses = [s for s in signals if s.result == 'L'] + [s for s in signals if s.result == 'W' and s.attempt == 3]  # Losses + G2
            
            print(f"üìä Total de sinais: {len(signals)}")
            print(f"‚úÖ Wins: {len(wins)} ({len(wins)/len(signals)*100:.1f}%)")
            print(f"‚ùå Losses: {len(losses)} ({len(losses)/len(signals)*100:.1f}%)")
            
            # Agrupar por tentativa
            first_attempt = [s for s in signals if s.result == 'W' and s.attempt == 1]
            g1_wins = [s for s in signals if s.result == 'W' and s.attempt == 2]
            g2_wins = [s for s in signals if s.result == 'W' and s.attempt == 3]
            
            print(f"üéØ 1¬™ tentativa: {len(first_attempt)} ({len(first_attempt)/len(signals)*100:.1f}%)")
            print(f"üîÑ G1 wins: {len(g1_wins)} ({len(g1_wins)/len(signals)*100:.1f}%)")
            print(f"üîÑ G2 wins: {len(g2_wins)} ({len(g2_wins)/len(signals)*100:.1f}%)")
            
            # Agrupar por ativo
            print(f"\nüí∞ SINAIS POR ATIVO:")
            assets = {}
            for signal in signals:
                if signal.asset not in assets:
                    assets[signal.asset] = {'first_wins': 0, 'g1_wins': 0, 'losses': 0}
                
                # Conforme estrat√©gias: apenas 1¬™ tentativa e G1 s√£o wins
                if signal.result == 'W' and signal.attempt == 1:
                    assets[signal.asset]['first_wins'] += 1
                elif signal.result == 'W' and signal.attempt == 2:
                    assets[signal.asset]['g1_wins'] += 1
                else:
                    # Losses reais + G2 (consideramos como losses)
                    assets[signal.asset]['losses'] += 1
            
            for asset, stats in sorted(assets.items()):
                wins = stats['first_wins'] + stats['g1_wins']  # Apenas 1¬™ tentativa + G1
                total = wins + stats['losses']
                win_rate = wins / total * 100 if total > 0 else 0
                print(f"   {asset}: {wins}W/{stats['losses']}L ({win_rate:.1f}%)")
            
            # An√°lise temporal por hora
            print(f"\n‚è∞ DISTRIBUI√á√ÉO TEMPORAL:")
            hourly = {}
            for signal in signals:
                hour = signal.timestamp.hour
                if hour not in hourly:
                    hourly[hour] = {'first_wins': 0, 'g1_wins': 0, 'losses': 0}
                
                # Conforme estrat√©gias: apenas 1¬™ tentativa e G1 s√£o wins
                if signal.result == 'W' and signal.attempt == 1:
                    hourly[hour]['first_wins'] += 1
                elif signal.result == 'W' and signal.attempt == 2:
                    hourly[hour]['g1_wins'] += 1
                else:
                    # Losses reais + G2 (consideramos como losses)
                    hourly[hour]['losses'] += 1
            
            for hour in sorted(hourly.keys()):
                stats = hourly[hour]
                wins = stats['first_wins'] + stats['g1_wins']  # Apenas 1¬™ tentativa + G1
                total = wins + stats['losses']
                win_rate = wins / total * 100 if total > 0 else 0
                print(f"   {hour:02d}:00-{hour:02d}:59: {total} sinais ({win_rate:.1f}% win rate)")
            
            # √öltimos sinais
            print(f"\nüìã √öLTIMOS 15 SINAIS:")
            print("-" * 50)
            for signal in signals[-15:]:
                attempt_str = f"G{signal.attempt}" if signal.attempt else "1¬™"
                result_str = "‚úÖ WIN" if signal.result == 'W' else "‚ùå LOSS"
                print(f"   {signal.timestamp.strftime('%H:%M')} | {signal.asset} | {result_str} | {attempt_str}")
            
        else:
            print("‚ö†Ô∏è Nenhum sinal encontrado hoje")
        
        await runner.cleanup()
        return signals
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        import traceback
        traceback.print_exc()
        if runner.client:
            await runner.cleanup()
        return []


async def analyze_full_day_conditions(signals):
    """Analisa condi√ß√µes do mercado com dados completos do dia."""
    print("\nüß† AN√ÅLISE COMPLETA DE CONDI√á√ïES DE MERCADO")
    print("=" * 70)
    
    if len(signals) < 5:
        print("‚ö†Ô∏è Poucos dados para an√°lise confi√°vel")
        return
    
    config = Config()
    adaptive = AdaptiveStrategy(config)
    
    # An√°lise geral do dia
    print("üìä AN√ÅLISE GERAL DO DIA COMPLETO:")
    conditions = adaptive.analyze_market_conditions(signals)
    print(f"   {conditions}")
    
    # An√°lise por per√≠odos de 1 hora
    if len(signals) >= 20:
        print("\nüìà AN√ÅLISE POR PER√çODOS (2h cada):")
        print("-" * 50)
        
        periods = {}
        for signal in signals:
            period = signal.timestamp.hour // 2 * 2  # 6-8, 8-10, 10-12, etc.
            if period not in periods:
                periods[period] = []
            periods[period].append(signal)
        
        for period_start in sorted(periods.keys()):
            period_signals = periods[period_start]
            if len(period_signals) >= 3:
                period_end = period_start + 2
                print(f"\n   üïê {period_start:02d}:00-{period_end:02d}:00 ({len(period_signals)} sinais):")
                period_conditions = adaptive.analyze_market_conditions(period_signals)
                print(f"      {period_conditions}")
    
    # An√°lise da √∫ltima 1 hora (mais relevante para previs√£o)
    print("\nüîÆ AN√ÅLISE DA √öLTIMA 1 HORA (MAIS RELEVANTE):")
    print("-" * 50)
    
    now = datetime.now(config.timezone)
    two_hours_ago = now - timedelta(hours=2)
    
    recent_signals = [s for s in signals if s.timestamp >= two_hours_ago]
    
    if len(recent_signals) >= 5:
        recent_conditions = adaptive.analyze_market_conditions(recent_signals)
        print(f"üìä Baseado nos √∫ltimos {len(recent_signals)} sinais (√∫ltimas 2h):")
        print(f"   {recent_conditions}")
        
        # Recomenda√ß√£o para 17:00-18:00
        strategy = recent_conditions.recommended_strategy
        confidence = recent_conditions.confidence_level
        
        print(f"\nüéØ RECOMENDA√á√ÉO PARA 17:00-18:00:")
        print("-" * 40)
        
        if strategy.value == 'pause':
            print("   ‚è∏Ô∏è  AGUARDAR - Condi√ß√µes desfavor√°veis detectadas")
            print("   üí° Sugest√£o: Monitorar primeiros sinais das 17:00")
            print("   üîç Reavalia√ß√£o: A cada 10 sinais ou √†s 18:00")
        elif strategy.value == 'martingale_conservative':
            print("   üé≤ MARTINGALE CONSERVATIVE - Alta recupera√ß√£o G1 detectada")
            print("   üí∞ ROI esperado: 56.0% mensal")
            print("   üéØ Estrutura: $4 ‚Üí $8 (m√°ximo 2 tentativas)")
        elif strategy.value == 'infinity_conservative':
            print("   ‚ôæÔ∏è  INFINITY CONSERVATIVE - Alta taxa 1¬™ tentativa detectada")
            print("   üí∞ ROI esperado: 45.1% mensal")
            print("   üéØ Estrutura: 7 n√≠veis progressivos")
        
        print(f"   üé≤ Confian√ßa: {confidence:.1f}%")
        
        # An√°lise de tend√™ncia
        if len(recent_signals) >= 10:
            first_half = recent_signals[:len(recent_signals)//2]
            second_half = recent_signals[len(recent_signals)//2:]
            
            # Conforme estrat√©gias: apenas 1¬™ tentativa e G1 s√£o wins
            first_wins = len([s for s in first_half if (s.result == 'W' and s.attempt in [1, 2])])
            second_wins = len([s for s in second_half if (s.result == 'W' and s.attempt in [1, 2])])
            first_win_rate = first_wins / len(first_half) * 100
            second_win_rate = second_wins / len(second_half) * 100
            
            trend = second_win_rate - first_win_rate
            
            print(f"\nüìà TEND√äNCIA RECENTE:")
            print(f"   1¬™ metade: {first_win_rate:.1f}% win rate")
            print(f"   2¬™ metade: {second_win_rate:.1f}% win rate")
            
            if trend > 5:
                print(f"   üìà Tend√™ncia POSITIVA (+{trend:.1f}%)")
            elif trend < -5:
                print(f"   üìâ Tend√™ncia NEGATIVA ({trend:.1f}%)")
            else:
                print(f"   ‚û°Ô∏è Tend√™ncia EST√ÅVEL ({trend:+.1f}%)")
    
    else:
        print(f"   ‚ö†Ô∏è Apenas {len(recent_signals)} sinais nas √∫ltimas 2h")
        print("   üìä Usando an√°lise do dia completo para previs√£o")
        
        if len(signals) >= 10:
            day_conditions = adaptive.analyze_market_conditions(signals)
            print(f"   {day_conditions}")


async def prepare_for_trading():
    """Prepara sistema para trading das 17:00-23:59."""
    print("\nüöÄ PREPARANDO SISTEMA PARA TRADING 17:00-23:59")
    print("=" * 70)
    
    now = datetime.now()
    target_time = now.replace(hour=17, minute=0, second=0, microsecond=0)
    
    if now >= target_time:
        print("‚úÖ J√° passou das 17:00 - Sistema pode iniciar imediatamente")
        print("üéØ Execute: python main_adaptive.py")
    else:
        wait_time = (target_time - now).total_seconds()
        wait_minutes = int(wait_time / 60)
        print(f"‚è∞ Aguardando {wait_minutes} minutos at√© 17:00")
        print(f"üéØ Sistema iniciar√° automaticamente √†s {target_time.strftime('%H:%M')}")
    
    print("\nüìã SISTEMA PRONTO PARA:")
    print("   ‚úÖ Monitoramento em tempo real (17:00-23:59)")
    print("   ‚úÖ An√°lise autom√°tica a cada hora")
    print("   ‚úÖ Sele√ß√£o adaptativa de estrat√©gia")
    print("   ‚úÖ Relat√≥rios detalhados")
    
    print("\nüéØ WORKFLOW DAS 17:00-18:00:")
    print("   1. Sistema inicia coleta em tempo real")
    print("   2. Primeiros 10 sinais ‚Üí An√°lise inicial")
    print("   3. 18:00 ‚Üí An√°lise completa da 1¬™ hora")
    print("   4. Sele√ß√£o/ajuste de estrat√©gia")
    print("   5. Continua at√© 23:59")


async def main():
    """Fun√ß√£o principal."""
    print("üéØ AN√ÅLISE COMPLETA DO DIA + PREPARA√á√ÉO PARA TRADING")
    print("=" * 80)
    print(f"üìÖ Data: {datetime.now().strftime('%d/%m/%Y')}")
    print(f"‚è∞ Hor√°rio atual: {datetime.now().strftime('%H:%M:%S')}")
    print("=" * 80)
    
    # Etapa 1: Coletar TODOS os sinais do dia
    signals = await collect_full_day_data()
    
    # Etapa 2: An√°lise completa das condi√ß√µes
    await analyze_full_day_conditions(signals)
    
    # Etapa 3: Preparar para trading
    await prepare_for_trading()
    
    print("\n" + "=" * 80)
    print("‚úÖ AN√ÅLISE COMPLETA CONCLU√çDA - SISTEMA PRONTO PARA TRADING!")
    print("üöÄ Execute: python main_adaptive.py")
    print("=" * 80)


if __name__ == "__main__":
    asyncio.run(main()) 